<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>andy's blog</title>
	<meta name="description" content="">
	<meta name="author" content="andy.zhangtao">

	<!-- HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="/theme/html5.js"></script>
	<![endif]-->

	<!-- Styles -->
	<link href="/theme/bootstrap.min.css" rel="stylesheet">
	<link href="/theme/local.css" rel="stylesheet">
	<link href="/theme/pygments.css" rel="stylesheet">

	<!-- Feeds -->
	<link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="andy's blog Atom Feed" />




<script>var _gaq=[['_setAccount','UA-71897460-1'],['_trackPageview']];(function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.src='//www.google-analytics.com/ga.js';s.parentNode.insertBefore(g,s)}(document,'script'))</script>
</head>
<body>
	<div class="topbar">
	  <div class="topbar-inner">
		<div class="container-fluid">
		  <a class="brand" href="/">andy's blog</a>
			<ul class="nav">
					<li ><a href="/category/docker.html">Docker</a></li>
					<li ><a href="/category/nodejs.html">Nodejs</a></li>
			</ul>
			<p class="pull-right"><a href="/archives.html">[archives]</a> <a href="/tags.html">[tags]</a></p>
		</div>
	  </div>
	</div>

	<div class="container-fluid">
	  <div class="sidebar">
		<div class="well">
			<h3>Blogroll</h3>
			<ul>
				<li><a href="http://getpelican.com/">Pelican</a></li>
				<li><a href="http://python.org/">Python.org</a></li>
				<li><a href="http://jinja.pocoo.org/">Jinja2</a></li>
				<li><a href="#">You can modify those links in your config file</a></li>
			</ul>
			<div class="social">
			<h3>Social</h3>
			<ul>
				<li><a href="#">You can add links in your config file</a></li>
				<li><a href="#">Another social link</a></li>
			</ul>
			</div>
		</div>
	  </div>
	  <div class="content">
<div class="page-header"><h1>andy's blog <small>andy.zhangtao</small></h1></div>
<div class='article'>
	<h2>Docker 如何管理Image,Container</h2>
	<div class="well small">Permalink: <a class="more" href="/docker-ru-he-guan-li-imagecontainer.html">2016-01-04 00:00:00+08:00</a>
by <a class="url fn" href="/author/andyzhangtao.html">andy.zhangtao </a>
 in <a href="/category/docker.html">Docker</a>
</div>
	<div class="summary"><h1>Docker 如何管理Image,Container？</h1>
<p>在使用Docker之前，有一个问题始终无法回避：Docker如何高效的管理和使用Image和Container数据？
为了搞明白这个问题，我们首先需要理解：</p>
<ol>
<li>Docker如何构建和存储Image？</li>
<li>Docker如何基于Image来创建Container？</li>
<li>Docker如何操作Image和Container？</li>
</ol>
<h2>Image和Container的基础 － Layers(文件层)</h2>
<p>从数据结构上面来看，Docker当中所有的Image都是一系列<strong>有序</strong>只读(Read-Only)文件层(Layers)的集合。位于这个集合最顶端的文件层，我们称之为BaseImage。其它文件层都依赖于它。下图是一个Ubuntu15.04的Image示意图，这个Image包含了4个文件层。
<img alt="image" src="https://lh3.googleusercontent.com/-D8MQPkSpeb8/VonUe0SEWKI/AAAAAAAAAAw/NXLg19gDpq4/s448-Ic42/image-layers.jpg" /></p>
<p>当用户在这个Container中做任何写操作时，例如：在/tmp目录中新创建一个文件，Docker就会在这个集合最下面再创建一个文件层来保存这种变化。Docker当中每个文件层都有一个唯一ID(UUID)，并且每个文件层都会记录其所依赖的文件层信息。</p>
<p>Image都是由Layers组成的，与此相对应的，所有的Container也同样是由Layers组成的。但Container与Image又一个本质区别，组成Image的Layer都是RO，而组成Container的Layer中，处于最低端的Layer是RW，其它Layer都是RO。这个RW的Layer，我们称之为Thin R/W Layer。如下图所示 ...</p> <a class="btn primary xsmall" href="/docker-ru-he-guan-li-imagecontainer.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>Docker输出日志的几种方式</h2>
	<div class="well small">Permalink: <a class="more" href="/dockershu-chu-ri-zhi-de-ji-chong-fang-shi.html">2016-01-04 00:00:00+08:00</a>
by <a class="url fn" href="/author/andyzhangtao.html">andy.zhangtao </a>
 in <a href="/category/docker.html">Docker</a>
</div>
	<div class="summary"><h1>Docker输出日志的几种方式</h1>
<p>在使用Docker过程中，查看日志是必不可少的一项工作。通过Docker提供的docker logs命令可以查看指定容器所输出的日志。但此命令有一些限制范围，当前docker logs命令仅仅只能支持json-file,journald这两种日志驱动，如果container使用其它类型的日志驱动，那么logs命令将无法提取日志。</p>
<p><strong>那么如何查看容器所输出的日志呢？</strong></p>
<p>为了解决这个问题，我们首先来看看Docker都支持哪些类型的日志驱动。</p>
<hr />
<h2>Docker支持的日志驱动类型</h2>
<p>Docker目前支持以下类型的驱动：</p>
<table>
<thead>
<tr>
<th>驱动名称</th>
<th>是否支持logs</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>json-file</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>journald</td>
<td>true</td>
<td></td>
</tr>
<tr>
<td>syslog</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>gelf</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>fluentd</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>awslogs</td>
<td>false</td>
<td></td>
</tr>
</tbody>
</table>
<h2>Docker如何指定日志驱动？</h2>
<hr />
<p>指定日志驱动有两种方式：</p>
<ul>
<li>通过Daemon指定全局默认日志驱动</li>
<li>通过Run命令指定特定日志驱动</li>
</ul>
<p>如果需要指定全局默认日志驱动，可以在启动Docker Daemon时指定，命令如下：</p>
<div class="highlight"><pre>docker daemon --log-driver=json-file --log-opt labels=foo --log-opt env=foo,fizz
</pre></div>


<p>当执行完这条命令之后 ...</p> <a class="btn primary xsmall" href="/dockershu-chu-ri-zhi-de-ji-chong-fang-shi.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>MockKoa - 一个基于Koa的API测试模拟服务器</h2>
	<div class="well small">Permalink: <a class="more" href="/mockkoa-yi-ge-ji-yu-koade-apice-shi-mo-ni-fu-wu-qi.html">2016-01-02 00:00:00+08:00</a>
by <a class="url fn" href="/author/andyzhangtao.html">andy.zhangtao </a>
 in <a href="/category/nodejs.html">Nodejs</a>
</div>
	<div class="summary"><h1>MockKoa － 一个基于Koa的API测试服务器</h1>
<p>来自于andy的博客<a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#97;&#110;&#100;&#121;&#46;&#122;&#104;&#97;&#110;&#103;&#116;&#97;&#111;&#64;&#104;&#111;&#116;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#97;&#110;&#100;&#121;&#46;&#122;&#104;&#97;&#110;&#103;&#116;&#97;&#111;&#64;&#104;&#111;&#116;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a></p>
<h2>MockKoa是什么？</h2>
<p>MockKoa是一个基于Koa＋nodejs的Rest API的测试服务器，说成是框架也可以，但我认为距离框架还有一些距离。</p>
<p>MockKoa使用nodejs来开发，通过Koa完成主要逻辑处理，可以加载以swagger为载体的API服务。(如果不了解swagger,<a href="www.swagger.io">请点击这里</a>)</p>
<p>目前MockKoa仅仅支持swagger格式，未来会考虑支持Yaml格式，但目前还没有具体时间安排。</p>
<h2>MockKoa可以做什么？</h2>
<p>MockKoa最重要的功能就是按照模拟策略生成API返回值，针对用户发起的每个API请求都可以生成唯一准确并且满足用户预期的返回值。</p>
<p>返回值包括：</p>
<ul>
<li>响应状态码</li>
<li>响应body数据</li>
<li>响应header数据</li>
</ul>
<h4>响应状态码</h4>
<p>MockKoa可以根据用户设定的模拟策略来返回指定的状态码。MockKoa支持多种模拟策略，并且支持一定的逻辑处理，但MockKoa不会自动生成状态码，这些状态码仍然需要用户明确指定。指定的方式可以是通过swagger文件指定或者通过用户自定义代码指定。</p>
<p>MockKoa在返回状态码时不会校验状态码是否有效，即便用户设定需要返回的响应码为601，MockKoa也会"乖顺"的返回此值。所以需要用户自行保证状态码是否有效。</p>
<p>同时，MockKoa不会处理重定向请求。对于重定向请求，需要客户端来处理，MockKoa模拟的是服务端，所以不需要处理重定向请求(有一些用户问过此问题，所以补充此处说明)。</p>
<h4>响应body数据</h4>
<p>MockKoa可以根据用户设定的body数据返回。 MockKoa默认设定Content—Type为<strong><em>*application ...</em></strong></p> <a class="btn primary xsmall" href="/mockkoa-yi-ge-ji-yu-koade-apice-shi-mo-ni-fu-wu-qi.html">more…</a>
	</div>
</div>	


		<footer>
		  <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme based on <a href="http://twitter.github.com/bootstrap/">Twitter Bootstrap</a>.</p>
		  <p>&copy; andy.zhangtao</p>
		</footer>
	  </div>

	</div>
</body>
</html>